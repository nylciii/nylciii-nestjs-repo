ðŸ“Œ Debugging & Managing Docker Containers


How can you check logs from a running container?

You can view the logs of a running container using the docker logs command.
It shows all the standard output (stdout) and error messages (stderr) generated by the containerized application.
Common examples:

docker logs <container_id>


To follow logs in real time (similar to tail -f):

docker logs -f <container_id>


For containers managed by Docker Compose, you can use:

docker compose logs


or to continuously stream logs:

docker compose logs -f


These commands help you monitor app behavior and diagnose issues without stopping the container.

What is the difference between docker exec and docker attach?
Command	Description	Use Case
docker exec -it <container_id> <command>	Starts a new shell session inside a running container without affecting its main process.	Safely debugging or running additional commands inside the container (e.g., bash, psql).
docker attach <container_id>	Connects directly to the containerâ€™s main process, sharing its stdout/stderr. Exiting it may stop the container.	Viewing or interacting with the primary process (not recommended for debugging).

âœ… In short:
Use docker exec for safe, interactive debugging.
Use docker attach only when you need to directly interact with the containerâ€™s main process.

How do you restart a container without losing data?

To restart a container:

docker restart <container_id>


This stops and starts the same container with all its data intact, as long as youâ€™re using Docker volumes or bind mounts for persistent storage.

If youâ€™re using Docker Compose, you can rebuild and restart services:

docker compose down
docker compose up -d


Your data will still persist because volumes are stored outside the containerâ€™s filesystem.
Only removing the volume manually (using docker volume rm) will delete stored data.

How can you troubleshoot database connection issues inside a containerized NestJS app?

When your NestJS app in Docker canâ€™t connect to the database, here are key debugging steps:

Check if the database container is running:

docker ps


Make sure your PostgreSQL (or other DB) container is listed and running.

Inspect network configuration:
Containers in the same Docker Compose network can communicate via service names.
Example connection string in NestJS:

DATABASE_HOST=db
DATABASE_PORT=5432


Here db should match the service name in your docker-compose.yml.

Check logs for both services:

docker compose logs db
docker compose logs api


Look for authentication errors, connection refused, or timeout messages.

Enter the NestJS container and test the connection:

docker exec -it api bash
ping db


or try connecting manually using psql if available:

psql -h db -U admin -d mydb


Verify environment variables:
Make sure your .env or docker-compose.yml has the correct credentials (DB name, user, password, host, and port).